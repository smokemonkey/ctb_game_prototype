# 开发笔记

## 锚定功能开发历程

### 需求来源
用户需要在游戏中为不同国家/角色设置不同的纪年系统，能够指定某个纪元的元年对应的公元年份，实现纪年的灵活切换。

### 设计演进

#### 第一版：复杂系统设计 ❌
- 创建了EraSystem数据类
- 支持多个纪元系统并存
- 复杂的系统切换逻辑
- **问题**: 过度设计，用户反馈"改的太大了"

#### 第二版：简化但仍复杂 ❌  
- 简化为EraAnchor概念
- 仍然保留系统管理功能
- **问题**: 仍然过于复杂，用户要求"最小改动"

#### 第三版：最小改动版本 ✅
- 只在原有代码基础上添加`anchor_era()`方法
- 修改`add_era_node()`基于锚定实现
- 修改`get_current_era()`优先使用锚定
- **成功**: 用户满意，功能完整

### 核心设计决策

#### 1. 锚定 vs 改元的区别
```python
# 锚定：可以指定任意年份
anchor_era("开元", 713)  # 开元元年=公元713年

# 改元：只能使用当前年份  
add_era_node("永徽")  # 永徽元年=当前年份
```

**原因**: 改元是历史概念，应该在当前时刻宣布新纪元开始，而不是追溯历史。

#### 2. 锚定优先级设计
```python
def get_current_era(self):
    # 1. 优先检查锚定
    if self._current_anchor:
        # 使用锚定计算
    
    # 2. 回退到原有逻辑
    for era in self._era_nodes:
        # 原有纪元节点逻辑
```

**原因**: 锚定是新功能，应该覆盖原有的纪元节点，但保持向后兼容。

#### 3. 未来时期限制
```python
if gregorian_year > current_year:
    raise ValueError("不能锚定到未来时期")
```

**原因**: 游戏逻辑上不应该允许锚定到还没发生的时期。

### Web界面开发历程

#### 过度设计问题
多次出现重写整个界面的情况，用户多次强调"不要重写，最小改动"。

#### 学到的教训
1. **理解现有结构**: 先充分了解现有代码再修改
2. **最小改动原则**: 只添加必要功能，不重构现有代码
3. **保持用户界面**: 不要随意改变用户已经熟悉的界面

### 技术实现细节

#### 锚定存储格式
```python
self._current_anchor: Optional[Tuple[str, int]] = None
# 存储为 (纪元名, 元年公元年份)
```

#### 纪元年份计算
```python
current_era_year = current_gregorian_year - era_start_year + 1
```

#### Web端同步
JavaScript端完全模拟Python端的逻辑，确保行为一致。

## 开发经验总结

### 与用户沟通
1. **理解真实需求**: 用户要的是"锚定功能"，不是"纪元系统重构"
2. **最小改动**: 在现有基础上添加，而不是重新设计
3. **及时反馈**: 用户不满意时立即调整方向

### 代码设计
1. **向后兼容**: 新功能不能破坏现有功能
2. **优先级设计**: 新功能优先，但保留原有逻辑作为回退
3. **简单实现**: 复杂的设计往往不如简单的实现

### 界面开发
1. **保持现有风格**: 不要随意改变用户熟悉的界面
2. **渐进式增强**: 在现有基础上添加功能
3. **功能分离**: 新功能独立区域，不影响原有控件

## 下次开发提醒

1. **先读现有代码**: 充分理解现有实现再开始修改
2. **最小改动原则**: 能不改的就不改
3. **用户反馈优先**: 用户说"太复杂"就立即简化
4. **保持测试**: 每次修改后确保原有功能正常 