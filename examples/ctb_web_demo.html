<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CTB系统演示 - 回合制战斗时间管理</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fomantic-ui@2.9.3/dist/semantic.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.9.3/dist/semantic.min.css">
    <script src="/config.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Microsoft YaHei', 'Simhei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr 350px;
            gap: 20px;
            padding: 20px;
            min-height: 600px;
        }

        .panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            border-left: 4px solid #3498db;
        }

        .panel h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }

        .info-text {
            font-family: 'Courier New', monospace;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            white-space: pre-line;
            font-size: 13px;
            line-height: 1.4;
            max-height: 200px;
            overflow-y: auto;
        }

        .scrollable-log {
            max-height: 300px;
            overflow-y: auto;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
        }

        .control-group h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin: 5px 0;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.success {
            background: linear-gradient(135deg, #27ae60 0%, #219a52 100%);
        }

        .btn.warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .btn.danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }

        .input-group label {
            color: #2c3e50;
            font-weight: bold;
            min-width: 80px;
        }

        .input-group input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
        }

        .input-group input:focus {
            outline: none;
            border-color: #3498db;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        @media (max-width: 1200px) {
            .content {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }

        .scrollbar {
            scrollbar-width: thin;
            scrollbar-color: #3498db #2c3e50;
        }

        .scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 4px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }

        .info-text, .scrollable-log {
            scrollbar-width: thin;
            scrollbar-color: #3498db #2c3e50;
        }

        .info-text::-webkit-scrollbar, .scrollable-log::-webkit-scrollbar {
            width: 6px;
        }

        .info-text::-webkit-scrollbar-track, .scrollable-log::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .info-text::-webkit-scrollbar-thumb, .scrollable-log::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 3px;
        }

        /* 行动顺序预测竖条样式 */
        .action-order-bar {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 500px; /* 加长预测栏 */
            padding: 10px 0;
            gap: 8px;
            background: linear-gradient(180deg, rgba(52, 152, 219, 0.1) 0%, rgba(52, 152, 219, 0.05) 100%);
            border-radius: 8px;
            border: 1px solid rgba(52, 152, 219, 0.2);
        }

        .action-order-avatar {
            position: absolute;
            width: 120px;
            height: 40px;
            border-radius: 6px;
            background: linear-gradient(135deg, #ecf0f1 0%, #bdc3c7 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #2c3e50;
            border: 2px solid #3498db;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            left: 50%;
            transform: translateX(-50%);
        }

        .action-order-avatar:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .action-order-avatar.active {
            border-color: #e67e22;
            box-shadow: 0 0 12px rgba(230, 126, 34, 0.6);
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            animation: pulse 2s infinite;
        }

        .action-order-avatar.predicted {
            border-color: #27ae60;
            box-shadow: 0 0 12px rgba(39, 174, 96, 0.6);
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }

        /* 引力坐标动画系统 */
        .action-order-avatar.gravity-moving {
            transition: top 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* 分层动画：前排快后排慢 */
        .action-order-avatar.gravity-fast {
            transition: top 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .action-order-avatar.gravity-medium {
            transition: top 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .action-order-avatar.gravity-slow {
            transition: top 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        /* 移动动画 */
        .action-order-avatar.moving {
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 瞬移动画 */
        .action-order-avatar.teleporting {
            transition: transform 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        /* 上浮动画 */
        .action-order-avatar.float-up {
            transition: top 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 消失动画 */
        .action-order-avatar.fade-out {
            transition: opacity 0.3s ease-out;
            opacity: 0;
        }

        .action-order-avatar .faction-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .action-order-avatar .time-info {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #7f8c8d;
            white-space: nowrap;
            background: rgba(255,255,255,0.9);
            padding: 2px 4px;
            border-radius: 3px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .action-order-avatar:hover .time-info {
            opacity: 1;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* 技能预测动画效果 */
        @keyframes float-up {
            0% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
            100% { transform: translateY(0); }
        }

        @keyframes float-down {
            0% { transform: translateY(0); }
            50% { transform: translateY(8px); }
            100% { transform: translateY(0); }
        }

        @keyframes breathing {
            0% {
                box-shadow: 0 0 12px rgba(231, 76, 60, 0.6);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
                transform: scale(1.05);
            }
            100% {
                box-shadow: 0 0 12px rgba(231, 76, 60, 0.6);
                transform: scale(1);
            }
        }

        @keyframes fade-in-out {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        @keyframes skill-applied {
            0% {
                transform: scale(1);
                box-shadow: 0 0 12px rgba(231, 76, 60, 0.6);
            }
            25% {
                transform: scale(1.2);
                box-shadow: 0 0 25px rgba(231, 76, 60, 0.9);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 12px rgba(231, 76, 60, 0.6);
            }
        }

        /* 延后角色样式 */
        .action-order-avatar.delayed {
            animation: breathing 2s infinite, float-up 3s ease-in-out infinite;
            border-color: #e74c3c !important;
            box-shadow: 0 0 12px rgba(231, 76, 60, 0.6) !important;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important;
            color: white !important;
        }

        /* 预测模式下的其他角色轻微下沉 */
        .action-order-avatar.prediction-mode {
            animation: float-down 3s ease-in-out infinite;
            opacity: 0.8;
        }

        /* 预测提示动画 */
        .prediction-hint {
            animation: fade-in-out 2s ease-in-out infinite;
        }

        /* 技能应用成功动画 */
        .action-order-avatar.skill-applied {
            animation: skill-applied 1s ease-in-out;
        }

        /* 阵营颜色映射 */
        .faction-shu { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%) !important; }
        .faction-wei { background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important; }
        .faction-wu { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%) !important; }
        .faction-qi { background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%) !important; }
        .faction-chu { background: linear-gradient(135deg, #27ae60 0%, #219a52 100%) !important; }
        .faction-yan { background: linear-gradient(135deg, #1abc9c 0%, #16a085 100%) !important; }
        .faction-han { background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%) !important; }
        .faction-zhao { background: linear-gradient(135deg, #e67e22 0%, #d35400 100%) !important; }
        .faction-neutral { background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%) !important; }
    </style>
</head>
<body>
    <div id="app" class="ui container">
        <div class="container">
            <div class="header">
                <h1>🏺 CTB系统演示</h1>
                <p>基于春秋时代的回合制战斗时间管理系统</p>
            </div>

            <div class="content">
                <!-- 左侧面板 -->
                <div>
                    <div class="panel">
                        <h3>📅 时间信息</h3>
                        <div class="info-text" id="timeInfo">等待初始化...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>👥 角色信息</h3>
                        <div class="info-text" id="characterInfo">等待初始化...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>🧭 行动顺序预测</h3>
                        <div class="action-order-bar" id="actionOrderBar">
                            <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                                等待初始化...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 中间面板 -->
                <div>
                    <div class="panel">
                        <h3>⚔️ CTB状态</h3>
                        <div class="info-text" id="ctbStatus">等待初始化...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>⏳ 行动队列</h3>
                        <div class="info-text" id="actionQueue">等待初始化...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>🔭 行动预测</h3>
                        <div class="info-text" id="predictionBar">等待初始化...</div>
                    </div>

                    <div class="panel" style="margin-top: 20px;">
                        <h3>📜 行动历史</h3>
                        <div class="scrollable-log" id="actionHistory">等待行动...</div>
                    </div>
                </div>

                <!-- 控制面板 -->
                <div class="controls">
                    <div class="control-group">
                        <h4>⚙️ 系统控制</h4>
                        <button class="btn success" onclick="initializeCTB()">🚀 初始化CTB</button>
                        <button class="btn" onclick="executeNextAction()">▶️ 执行下个行动</button>
                        <button class="btn warning" onclick="skipToNext()">⏭️ 跳转时间</button>
                        <button class="btn danger" onclick="resetCTB()">🔄 重置系统</button>
                    </div>

                    <div class="control-group">
                        <h4>🎛️ 参数调整</h4>
                        <div class="input-group">
                            <label>基础因子:</label>
                            <input type="number" id="factorInput" value="100" min="1" max="1000">
                            <button class="btn" onclick="changeBaseFactor()" style="width: auto; margin: 0;">设置</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h4>🎮 测试功能</h4>
                        <button class="btn" onclick="toggleCharacterActive()">🔄 切换角色状态</button>
                        <button class="btn" onclick="addRandomCharacter()">➕ 添加随机角色</button>
                        <button class="btn" onclick="showPredictionDemo()">🔮 预测演示</button>
                        <button class="btn" onclick="runMediumTest()">⚡ 100人测试</button>
                        <button class="btn warning" onclick="runStressTest()">🚀 初始化 (压测模式)</button>
                        <button class="btn" onclick="testGravityAnimation()">🎯 测试引力动画</button>
                    </div>

                    <div class="control-group">
                        <h4>⚡ 技能系统</h4>
                        <div class="input-group">
                            <label>目标角色:</label>
                            <select id="skillTargetSelect" style="flex: 1; padding: 8px 12px; border: 2px solid #bdc3c7; border-radius: 4px; font-size: 14px;">
                                <option value="">选择角色...</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>延后小时:</label>
                            <input type="number" id="delayHoursInput" value="5" min="1" max="100" style="flex: 1;">
                        </div>
                        <button class="btn" onclick="predictSkillEffect()">🔮 预测效果</button>
                        <button class="btn success" onclick="applySkillEffect()">✨ 应用技能</button>
                        <button class="btn warning" onclick="clearPrediction()">🔄 清除预测</button>
                    </div>

                    <div class="control-group">
                        <h4>📊 系统状态</h4>
                        <div style="font-size: 12px; color: #7f8c8d;">
                            <div>系统状态: <span id="systemStatus" style="font-weight: bold;">未初始化</span></div>
                            <div>角色数量: <span id="characterCount">0</span></div>
                            <div>行动总数: <span id="actionCount">0</span></div>
                            <div id="stressTestResult" style="margin-top: 10px; white-space: pre-wrap; font-weight: bold; color: #27ae60; font-size: 13px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 模拟的后端数据
        let gameState = {
            timeManager: {
                currentYear: window.gameConfig.EPOCH_START_YEAR,
                currentMonth: 1,
                currentDay: 1,
                currentHour: 0,
                totalHours: 0
            },
            ctbManager: {
                isInitialized: false,
                baseFactor: 100,
                characters: [],
                actionQueue: [],
                actionHistory: [],
                nextActionId: 1
            }
        };

        // 测试角色数据 (对应 examples/data/ctb_characters.py 中的基础角色组)
        const testCharacters = [
            { id: 1, name: "张三", faction: "蜀国", speed: 5, isActive: true },
            { id: 2, name: "李四", faction: "魏国", speed: 7, isActive: true },
            { id: 3, name: "王五", faction: "吴国", speed: 10, isActive: true }
        ];

        // 更新所有显示
        function updateAllDisplays() {
            updateTimeDisplay();
            updateCTBStatus();
            updateCharacterInfo();
            updateActionQueue();
            updatePredictionBar();
            updateActionOrderBar();
            updateSystemStatus();
            updateSkillTargetSelect();
        }

        // 更新时间显示
        function updateTimeDisplay() {
            const tm = gameState.timeManager;
            const year = Math.abs(tm.currentYear);
            const era = tm.currentYear < 0 ? "公元前" : "公元";
            const eraYear = tm.currentYear - window.gameConfig.EPOCH_START_YEAR + 1;

            const timeText = `当前时间: ${era}${year}年${tm.currentMonth}月${tm.currentDay}日${tm.currentHour}点
纪年: 春秋${eraYear}年${tm.currentMonth}月${tm.currentDay}日${tm.currentHour}点
总计小时: ${tm.totalHours}
总计天数: ${Math.floor(tm.totalHours / 24)}`;

            document.getElementById('timeInfo').textContent = timeText;
        }

        // 更新CTB状态
        function updateCTBStatus() {
            const ctb = gameState.ctbManager;
            const statusText = `系统状态: ${ctb.isInitialized ? '已初始化' : '未初始化'}
基础因子: ${ctb.baseFactor}
活跃角色: ${ctb.characters.filter(c => c.isActive).length}/${ctb.characters.length}
队列长度: ${ctb.actionQueue.length}
历史记录: ${ctb.actionHistory.length}`;

            document.getElementById('ctbStatus').textContent = statusText;
        }

        // 更新角色信息
        function updateCharacterInfo() {
            const characters = gameState.ctbManager.characters;
            let text = `=== 角色列表 (共 ${characters.length} 个) ===\n`;
            const displayLimit = 20;

            const charactersToShow = characters.slice(0, displayLimit);

            charactersToShow.forEach(char => {
                const status = char.isActive ? "✓" : "✗";
                const interval = Math.ceil(gameState.ctbManager.baseFactor / char.speed);
                text += `${status} ${char.name} (${char.faction})\n`;
                text += `  速度:${char.speed.toFixed(2)} 间隔:${interval}天\n`;
            });

            if (characters.length > displayLimit) {
                text += `\n... (仅显示前 ${displayLimit} 个角色)`;
            }

            document.getElementById('characterInfo').textContent = text;
        }

        // 更新行动队列
        function updateActionQueue() {
            const queue = gameState.ctbManager.actionQueue;
            let text = "=== 行动队列 ===\n";

            queue.slice(0, 8).forEach((action, index) => {
                const timeUntil = action.triggerTime - gameState.timeManager.totalHours;
                const days = Math.floor(timeUntil / 24);
                const hours = Math.floor(timeUntil % 24);

                if (index === 0) {
                    text += `→ ${action.characterName}\n`;
                } else {
                    text += `  ${action.characterName}\n`;
                }
                text += `    ${days}天${hours}小时后\n`;
            });

            document.getElementById('actionQueue').textContent = text;
        }

        // 更新预测条
        function updatePredictionBar() {
            const predictions = predictFutureActions(10); // 预测未来10个行动
            let text = "=== 未来10次行动预测 ===\n";

            if (predictions.length === 0) {
                text = "无法预测（队列为空或未初始化）";
            } else {
                predictions.forEach((action, index) => {
                    const timeUntil = action.triggerTime - gameState.timeManager.totalHours;
                    const days = Math.floor(timeUntil / 24);
                    const hours = Math.floor(timeUntil % 24);

                    text += `${String(index + 1).padStart(2, ' ')}. ${action.characterName}\n`;
                    text += `     将在 ${days}天${hours}小时后行动\n`;
                });
            }

            document.getElementById('predictionBar').textContent = text;
        }

        // 更新行动顺序预测竖条
        function updateActionOrderBar(predictedOrder = null) {
            const bar = document.getElementById('actionOrderBar');
            const ctb = gameState.ctbManager;

            if (!ctb.isInitialized || ctb.actionQueue.length === 0) {
                bar.innerHTML = '<div style="text-align: center; color: #7f8c8d; padding: 20px;">等待初始化...</div>';
                return;
            }

            // 使用预测顺序或当前顺序
            const order = predictedOrder || ctb.actionQueue;

            // 检查是否需要重新创建DOM元素
            const existingAvatars = bar.querySelectorAll('.action-order-avatar');
            const needRecreate = existingAvatars.length === 0 ||
                                existingAvatars.length !== Math.min(order.length, 8) ||
                                // 检查角色ID是否发生变化
                                Array.from(existingAvatars).some((avatar, index) => {
                                    if (index >= order.length) return true;
                                    const character = gameState.ctbManager.characters.find(c => c.id === order[index].characterId);
                                    return character && avatar.dataset.characterId != character.id;
                                });

            if (needRecreate) {
                // 重新创建DOM元素
                bar.innerHTML = '';

                // 显示前8个行动
                order.slice(0, 8).forEach((action, index) => {
                    const character = gameState.ctbManager.characters.find(c => c.id === action.characterId);
                    if (!character) return;

                    const avatarDiv = document.createElement('div');
                    avatarDiv.className = 'action-order-avatar';
                    avatarDiv.dataset.characterId = character.id;
                    avatarDiv.dataset.index = index;

                    // 设置初始位置
                    const avatarHeight = 48; // 40px + 8px gap
                    avatarDiv.style.top = `${index * avatarHeight}px`;

                    // 添加阵营样式或自定义颜色
                    if (character.customColor) {
                        // 使用自定义颜色
                        avatarDiv.style.background = `linear-gradient(135deg, ${character.customColor} 0%, ${darkenColor(character.customColor, 0.2)} 100%)`;
                        avatarDiv.style.color = 'white';
                    } else {
                        // 使用阵营样式
                        const factionClass = getFactionClass(character.faction);
                        if (factionClass) {
                            avatarDiv.classList.add(factionClass);
                        }
                    }

                    // 当前行动高亮
                    if (index === 0) {
                        avatarDiv.classList.add('active');
                    }

                    // 头像内容（显示全名）
                    avatarDiv.textContent = character.name;

                    // 阵营徽章
                    const badgeDiv = document.createElement('div');
                    badgeDiv.className = 'faction-badge';
                    badgeDiv.textContent = character.faction[0];
                    badgeDiv.style.backgroundColor = character.customColor || getFactionColor(character.faction);
                    avatarDiv.appendChild(badgeDiv);

                    // 时间信息
                    const timeDiv = document.createElement('div');
                    timeDiv.className = 'time-info';
                    const timeUntil = action.triggerTime - gameState.timeManager.totalHours;
                    const days = Math.floor(timeUntil / 24);
                    const hours = Math.floor(timeUntil % 24);
                    if (days > 0) {
                        timeDiv.textContent = `${days}天${hours}时`;
                    } else {
                        timeDiv.textContent = `${hours}时`;
                    }
                    avatarDiv.appendChild(timeDiv);

                    // 点击事件（可以扩展为技能选择等）
                    avatarDiv.onclick = function() {
                        showCharacterDetails(character, action);
                    };

                    bar.appendChild(avatarDiv);
                });
            } else {
                // 只更新现有元素的内容和位置，不重新创建
                const avatars = bar.querySelectorAll('.action-order-avatar');
                order.slice(0, 8).forEach((action, index) => {
                    if (index < avatars.length) {
                        const avatar = avatars[index];
                        const character = gameState.ctbManager.characters.find(c => c.id === action.characterId);
                        if (character) {
                            // 更新文本内容
                            avatar.textContent = character.name;
                            avatar.dataset.characterId = character.id;

                            avatar.dataset.index = index;

                            // 更新时间信息
                            const timeDiv = avatar.querySelector('.time-info');
                            if (timeDiv) {
                                const timeUntil = action.triggerTime - gameState.timeManager.totalHours;
                                const days = Math.floor(timeUntil / 24);
                                const hours = Math.floor(timeUntil % 24);
                                if (days > 0) {
                                    timeDiv.textContent = `${days}天${hours}时`;
                                } else {
                                    timeDiv.textContent = `${hours}时`;
                                }
                            }

                            // 更新阵营徽章
                            const badgeDiv = avatar.querySelector('.faction-badge');
                            if (badgeDiv) {
                                badgeDiv.style.backgroundColor = character.customColor || getFactionColor(character.faction);
                            }
                        }
                    }
                });
            }

            // 如果是预测模式，执行队列插队动画
            if (predictedOrder && currentPrediction) {
                executeQueueAnimation(predictedOrder, currentPrediction);
            }

            // 如果行动数量超过8个，显示更多提示
            if (order.length > 8) {
                const moreDiv = document.createElement('div');
                moreDiv.style.textAlign = 'center';
                moreDiv.style.color = '#7f8c8d';
                moreDiv.style.fontSize = '12px';
                moreDiv.style.marginTop = '10px';
                moreDiv.textContent = `还有 ${order.length - 8} 个行动...`;
                bar.appendChild(moreDiv);
            }

            // 如果是预测模式，显示预测提示
            if (predictedOrder && currentPrediction) {
                const predictionDiv = document.createElement('div');
                predictionDiv.className = 'prediction-hint';
                predictionDiv.style.textAlign = 'center';
                predictionDiv.style.color = '#27ae60';
                predictionDiv.style.fontSize = '12px';
                predictionDiv.style.marginTop = '10px';
                predictionDiv.style.fontWeight = 'bold';
                predictionDiv.textContent = `🔮 预测模式：${currentPrediction.characterName} 延后 ${currentPrediction.delayHours} 小时`;
                bar.appendChild(predictionDiv);
            }
        }

        // 执行队列插队动画
        function executeQueueAnimation(predictedOrder, prediction) {
            const bar = document.getElementById('actionOrderBar');
            const avatars = bar.querySelectorAll('.action-order-avatar');
            const avatarHeight = 48;

            // 找到目标角色在原始队列和新队列中的位置
            const originalOrder = gameState.ctbManager.actionQueue.slice(0, 8);
            const targetCharacterId = prediction.characterId;

            const oldIndex = originalOrder.findIndex(action => action.characterId == targetCharacterId);
            const newIndex = predictedOrder.findIndex(action => action.characterId == targetCharacterId);

            if (oldIndex === -1 || newIndex === -1) return;

            // 清除所有引力目标
            gravityTargets.clear();

            // 设置所有角色的引力目标坐标
            avatars.forEach(avatar => {
                const avatarIndex = parseInt(avatar.dataset.index);
                const characterId = avatar.dataset.characterId;

                if (characterId == targetCharacterId) {
                    // 目标角色瞬移（不使用引力坐标）
                    setTimeout(() => {
                        avatar.style.transition = 'none'; // 瞬移
                        avatar.style.top = `${newIndex * avatarHeight}px`;
                        avatar.dataset.index = newIndex;

                        // 添加延后标识
                        avatar.style.borderColor = '#e74c3c';
                        avatar.style.boxShadow = '0 0 12px rgba(231, 76, 60, 0.6)';
                        avatar.style.background = 'linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)';
                        avatar.style.color = 'white';

                        // 恢复过渡动画
                        setTimeout(() => {
                            avatar.style.transition = '';
                        }, 50);
                    }, 200);
                } else {
                    // 其他角色使用引力坐标移动
                    let targetIndex = avatarIndex;
                    if (oldIndex < newIndex) {
                        // 向后移动：被跨过的角色向前补位
                        if (avatarIndex > oldIndex && avatarIndex <= newIndex) {
                            targetIndex = avatarIndex - 1;
                        }
                    } else {
                        // 向前移动：被跨过的角色向后让位
                        if (avatarIndex >= newIndex && avatarIndex < oldIndex) {
                            targetIndex = avatarIndex + 1;
                        }
                    }

                    if (targetIndex !== avatarIndex) {
                        setGravityTarget(characterId, targetIndex);
                    }
                }
            });

            // 立即应用引力动画
            applyGravityAnimation();
        }

        // 获取阵营CSS类名
        function getFactionClass(faction) {
            const factionMap = {
                '蜀国': 'faction-shu',
                '魏国': 'faction-wei',
                '吴国': 'faction-wu',
                '齐国': 'faction-qi',
                '楚国': 'faction-chu',
                '燕国': 'faction-yan',
                '韩国': 'faction-han',
                '赵国': 'faction-zhao',
                '中立': 'faction-neutral'
            };
            return factionMap[faction] || '';
        }

        // 获取阵营颜色
        function getFactionColor(faction) {
            const colorMap = {
                '蜀国': '#e74c3c',
                '魏国': '#3498db',
                '吴国': '#f39c12',
                '齐国': '#9b59b6',
                '楚国': '#27ae60',
                '燕国': '#1abc9c',
                '韩国': '#34495e',
                '赵国': '#e67e22',
                '中立': '#95a5a6'
            };
            return colorMap[faction] || '#95a5a6';
        }

        // 颜色变暗辅助函数
        function darkenColor(color, factor) {
            // 简单的颜色变暗算法
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - factor));
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - factor));
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - factor));
            return `#${Math.round(r).toString(16).padStart(2, '0')}${Math.round(g).toString(16).padStart(2, '0')}${Math.round(b).toString(16).padStart(2, '0')}`;
        }

        // 显示角色详情（可扩展为技能选择等）
        function showCharacterDetails(character, action) {
            const timeUntil = action.triggerTime - gameState.timeManager.totalHours;
            const days = Math.floor(timeUntil / 24);
            const hours = Math.floor(timeUntil % 24);

            let timeText = '';
            if (days > 0) {
                timeText = `${days}天${hours}小时后`;
            } else {
                timeText = `${hours}小时后`;
            }

            addActionLog(`角色详情: ${character.name} (${character.faction}) - 速度:${character.speed} - ${timeText}行动`);
        }

        // 更新系统状态
        function updateSystemStatus() {
            const ctb = gameState.ctbManager;
            document.getElementById('systemStatus').textContent = ctb.isInitialized ? '已初始化' : '未初始化';
            document.getElementById('characterCount').textContent = ctb.characters.length;
            document.getElementById('actionCount').textContent = ctb.actionHistory.length;
        }

        // 添加行动历史记录
        function addActionLog(message) {
            const historyDiv = document.getElementById('actionHistory');
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

            historyDiv.appendChild(logEntry);
            historyDiv.scrollTop = historyDiv.scrollHeight;

            // 保持最新50条记录
            while (historyDiv.children.length > 50) {
                historyDiv.removeChild(historyDiv.firstChild);
            }
        }

        // 预测未来行动
        function predictFutureActions(count) {
            const ctb = gameState.ctbManager;
            if (!ctb.isInitialized || ctb.actionQueue.length === 0) {
                return [];
            }

            // 使用深拷贝创建模拟环境
            let simQueue = JSON.parse(JSON.stringify(ctb.actionQueue));

            const predictions = [];

            for (let i = 0; i < count; i++) {
                if (simQueue.length === 0) break;

                // 获取下一个行动 (JS中shift()从数组头部取出)
                const nextAction = simQueue.shift();
                predictions.push(nextAction);

                // 安排该角色的下一次行动
                const character = ctb.characters.find(c => c.id === nextAction.characterId);
                if (character && character.isActive) {
                    const interval = Math.ceil(ctb.baseFactor / character.speed);
                    const nextTriggerTime = nextAction.triggerTime + (interval * 24);

                    simQueue.push({
                        id: -1, // 模拟行动ID
                        characterId: character.id,
                        characterName: character.name,
                        triggerTime: nextTriggerTime,
                        actionType: 'attack'
                    });

                    // 保持模拟队列排序
                    simQueue.sort((a, b) => a.triggerTime - b.triggerTime);
                }
            }

            return predictions;
        }

        // CTB系统控制函数
        function initializeCTB() {
            gameState.ctbManager.characters = [...testCharacters];
            gameState.ctbManager.isInitialized = true;
            gameState.ctbManager.actionQueue = [];

            // 生成初始行动队列
            gameState.ctbManager.characters.forEach(char => {
                if (char.isActive) {
                    const baseFactor = gameState.ctbManager.baseFactor;
                    const intervalDays = Math.ceil(baseFactor / char.speed);
                    const intervalHours = intervalDays * 24;

                    // 首次行动时间在 (0, intervalHours] 区间内随机分布
                    // 这避免了所有角色在同一天同步其行动周期
                    const initialDelayHours = Math.floor(Math.random() * intervalHours) + 1;
                    const triggerTime = gameState.timeManager.totalHours + initialDelayHours;

                    gameState.ctbManager.actionQueue.push({
                        id: gameState.ctbManager.nextActionId++,
                        characterId: char.id,
                        characterName: char.name,
                        triggerTime: triggerTime,
                        actionType: 'attack'
                    });
                }
            });

            // 按触发时间排序
            gameState.ctbManager.actionQueue.sort((a, b) => a.triggerTime - b.triggerTime);

            addActionLog("CTB系统已初始化");
            updateAllDisplays();
        }

        function executeNextAction() {
            if (!gameState.ctbManager.isInitialized) {
                addActionLog("请先初始化CTB系统");
                return;
            }

            // 使用引力坐标系统执行动画
            const bar = document.getElementById('actionOrderBar');
            const avatars = bar.querySelectorAll('.action-order-avatar');
            const avatarHeight = 48;

            if (avatars.length > 0) {
                // 清除所有引力目标
                gravityTargets.clear();

                // 第一个头像使用引力坐标移动到最底部（消失效果）
                const firstAvatar = avatars[0];
                const firstCharacterId = firstAvatar.dataset.characterId;
                setGravityTarget(firstCharacterId, -1); // 移动到-1位置（底部外）

                // 其他头像使用引力坐标上浮
                for (let i = 1; i < avatars.length; i++) {
                    const avatar = avatars[i];
                    const characterId = avatar.dataset.characterId;
                    const newIndex = i - 1;

                    // 设置引力目标
                    setGravityTarget(characterId, newIndex);
                }

                // 应用引力动画
                applyGravityAnimation();

                // 动画完成后执行实际逻辑
                setTimeout(() => {
                    executeNextActionLogic();
                }, 600); // 等待动画完成
            } else {
                executeNextActionLogic();
            }
        }

        // 实际的执行逻辑
        function executeNextActionLogic() {
            const action = gameState.ctbManager.actionQueue.shift();
            if (!action) {
                addActionLog("没有待执行的行动");
                return;
            }

            // 推进时间到行动时间
            gameState.timeManager.totalHours = action.triggerTime;
            updateTimeFromTotalHours();

            // 记录行动
            const tm = gameState.timeManager;
            const year = Math.abs(tm.currentYear);
            const era = tm.currentYear < 0 ? "公元前" : "公元";
            const eraYear = tm.currentYear - window.gameConfig.EPOCH_START_YEAR + 1;

            const logMessage = `春秋${eraYear}年${tm.currentMonth}月${tm.currentDay}日${tm.currentHour}点 (${era}${year}年${tm.currentMonth}月${tm.currentDay}日${tm.currentHour}点) - ${action.characterName} 行动`;
            addActionLog(logMessage);

            // 添加到历史
            gameState.ctbManager.actionHistory.push({
                ...action,
                executedTime: action.triggerTime,
                timestamp: Date.now()
            });

            // 为该角色安排下次行动
            const character = gameState.ctbManager.characters.find(c => c.id === action.characterId);
            if (character && character.isActive) {
                const interval = Math.ceil(gameState.ctbManager.baseFactor / character.speed);
                const nextTriggerTime = action.triggerTime + (interval * 24);

                gameState.ctbManager.actionQueue.push({
                    id: gameState.ctbManager.nextActionId++,
                    characterId: character.id,
                    characterName: character.name,
                    triggerTime: nextTriggerTime,
                    actionType: 'attack'
                });

                // 重新排序队列
                gameState.ctbManager.actionQueue.sort((a, b) => a.triggerTime - b.triggerTime);
            }

            // 延迟更新显示，让引力动画完成
            setTimeout(() => {
                updateAllDisplays();
            }, 100);
        }

        function skipToNext() {
            if (!gameState.ctbManager.isInitialized) {
                addActionLog("请先初始化CTB系统");
                return;
            }

            const nextAction = gameState.ctbManager.actionQueue[0];
            if (!nextAction) {
                addActionLog("没有待执行的行动");
                return;
            }

            // 直接跳转时间
            gameState.timeManager.totalHours = nextAction.triggerTime;
            updateTimeFromTotalHours();

            addActionLog(`时间已跳转到 ${nextAction.characterName} 的行动时间`);
            updateAllDisplays();
        }

        function changeBaseFactor() {
            const newFactor = parseInt(document.getElementById('factorInput').value);
            if (newFactor && newFactor > 0) {
                gameState.ctbManager.baseFactor = newFactor;
                addActionLog(`基础因子已修改为: ${newFactor}`);
                updateAllDisplays();
            } else {
                addActionLog("基础因子必须大于0");
            }
        }

        function resetCTB(silent = false) {
            gameState.ctbManager = {
                isInitialized: false,
                baseFactor: 100,
                characters: [],
                actionQueue: [],
                actionHistory: [],
                nextActionId: 1
            };

            document.getElementById('factorInput').value = "100";
            if (!silent) {
                addActionLog("CTB系统已重置");
            }
            // Clear stress test results on reset
            const resultDiv = document.getElementById('stressTestResult');
            if (resultDiv) resultDiv.textContent = "";

            updateAllDisplays();
        }

        function toggleCharacterActive() {
            if (gameState.ctbManager.characters.length > 0) {
                const char = gameState.ctbManager.characters[0];
                char.isActive = !char.isActive;
                const status = char.isActive ? "激活" : "停用";
                addActionLog(`${char.name} 已${status}`);
                updateAllDisplays();
            }
        }

        function addRandomCharacter() {
            const names = ["赵六", "孙七", "周八", "吴九", "郑十"];
            const factions = ["齐国", "楚国", "燕国", "韩国", "赵国"];

            const randomName = names[Math.floor(Math.random() * names.length)];
            const randomFaction = factions[Math.floor(Math.random() * factions.length)];
            const randomSpeed = Math.floor(Math.random() * 8) + 3; // 3-10

            const newChar = {
                id: Date.now(),
                name: randomName,
                faction: randomFaction,
                speed: randomSpeed,
                isActive: true
            };

            gameState.ctbManager.characters.push(newChar);
            addActionLog(`添加角色: ${randomName}(${randomFaction}) 速度:${randomSpeed}`);
            updateAllDisplays();
        }

        // 预测演示功能
        function showPredictionDemo() {
            if (!gameState.ctbManager.isInitialized) {
                addActionLog("请先初始化CTB系统");
                return;
            }

            const ctb = gameState.ctbManager;
            if (ctb.actionQueue.length < 2) {
                addActionLog("需要至少2个行动才能演示预测效果");
                return;
            }

            // 创建预测顺序（模拟第一个角色行动后，第二个角色提前行动）
            const predictedOrder = [...ctb.actionQueue];

            // 模拟第一个角色行动后，第二个角色的行动时间提前
            if (predictedOrder.length >= 2) {
                const firstAction = predictedOrder[0];
                const secondAction = predictedOrder[1];

                // 模拟第二个角色因为某种技能或效果提前行动
                const timeAdvance = Math.floor(Math.random() * 24) + 1; // 提前1-24小时
                secondAction.triggerTime = firstAction.triggerTime + timeAdvance;

                // 重新排序
                predictedOrder.sort((a, b) => a.triggerTime - b.triggerTime);

                addActionLog(`🔮 预测演示: 假设${firstAction.characterName}行动后，${secondAction.characterName}提前${timeAdvance}小时行动`);

                // 显示预测效果
                updateActionOrderBar(predictedOrder);

                // 3秒后恢复原始显示
                setTimeout(() => {
                    updateActionOrderBar();
                    addActionLog("预测演示结束，恢复原始顺序");
                }, 3000);
            }
        }

        // 从总小时数更新日期时间
        function updateTimeFromTotalHours() {
            const totalHours = gameState.timeManager.totalHours;
            const totalDays = Math.floor(totalHours / 24);
            const hours = totalHours % 24;

            // 简化的日期计算（360天/年，30天/月）
            const startYear = window.gameConfig.EPOCH_START_YEAR;
            const years = Math.floor(totalDays / 360);
            const remainingDays = totalDays % 360;
            const months = Math.floor(remainingDays / 30);
            const days = remainingDays % 30;

            gameState.timeManager.currentYear = startYear + years;
            gameState.timeManager.currentMonth = months + 1;
            gameState.timeManager.currentDay = days + 1;
            gameState.timeManager.currentHour = hours;
        }

        // 100人测试模式
        function runMediumTest() {
            addActionLog("⚡ 开始100人测试初始化...");

            const resultDiv = document.getElementById('stressTestResult');
            resultDiv.textContent = "初始化中...";

            setTimeout(() => {
                try {
                    // 1. 重置系统状态
                    resetCTB(true);

                    // 2. 设置参数
                    const characterCount = 100;
                    const averageIntervalDays = 30; // 更短的间隔，便于观察
                    const baseFactor = gameState.ctbManager.baseFactor;
                    const targetSpeed = baseFactor / averageIntervalDays;

                    // 3. 生成随机名字和颜色
                    const surnames = ['张', '李', '王', '赵', '陈', '刘', '杨', '黄', '周', '吴', '徐', '孙', '胡', '朱', '高', '林', '何', '郭', '马', '罗', '梁', '宋', '郑', '谢', '韩', '唐', '冯', '于', '董', '萧', '程', '曹', '袁', '邓', '许', '傅', '沈', '曾', '彭', '吕', '苏', '卢', '蒋', '蔡', '贾', '丁', '魏', '薛', '叶', '阎', '余', '潘', '杜', '戴', '夏', '钟', '汪', '田', '任', '姜', '范', '方', '石', '姚', '谭', '廖', '邹', '熊', '金', '陆', '郝', '孔', '白', '崔', '康', '毛', '邱', '秦', '江', '史', '顾', '侯', '邵', '孟', '龙', '万', '段', '雷', '钱', '汤', '尹', '黎', '易', '常', '武', '乔', '贺', '赖', '龚', '文'];
                    const givenNames = ['伟', '芳', '娜', '秀英', '敏', '静', '丽', '强', '磊', '军', '洋', '勇', '艳', '杰', '娟', '涛', '明', '超', '秀兰', '霞', '平', '刚', '桂英', '建华', '建国', '建军', '建平', '建华', '建明', '建强', '建伟', '建勇', '建杰', '建波', '建涛', '建斌', '建辉', '建峰', '建林', '建东', '建南', '建西', '建北', '建中', '建和', '建安', '建康', '建文', '建武', '建德', '建仁', '建义', '建礼', '建智', '建信', '建忠', '建孝', '建节', '建廉', '建耻', '建勇', '建刚', '建强', '建伟', '建杰', '建波', '建涛', '建斌', '建辉', '建峰', '建林', '建东', '建南', '建西', '建北', '建中', '建和', '建安', '建康', '建文', '建武', '建德', '建仁', '建义', '建礼', '建智', '建信', '建忠', '建孝', '建节', '建廉', '建耻'];
                    const factions = ['蜀国', '魏国', '吴国', '齐国', '楚国', '燕国', '韩国', '赵国', '秦国', '晋国', '宋国', '卫国', '郑国', '鲁国', '越国', '中山国', '滕国', '薛国', '莒国', '邾国', '郯国', '小邾国', '鄫国', '鄅国', '鄫国', '鄅国', '鄅国', '鄅国', '鄅国', '鄅国'];

                    // 预生成随机颜色池
                    const colorPool = [
                        '#e74c3c', '#3498db', '#f39c12', '#9b59b6', '#27ae60', '#1abc9c', '#34495e', '#e67e22',
                        '#8e44ad', '#2980b9', '#d35400', '#c0392b', '#16a085', '#f1c40f', '#e74c3c', '#3498db',
                        '#f39c12', '#9b59b6', '#27ae60', '#1abc9c', '#34495e', '#e67e22', '#8e44ad', '#2980b9',
                        '#d35400', '#c0392b', '#16a085', '#f1c40f', '#95a5a6', '#7f8c8d', '#2c3e50', '#ecf0f1'
                    ];

                    const newCharacters = [];
                    let totalActionsPerDay = 0;

                    // 4. 生成角色并计算理论平均值
                    for (let i = 0; i < characterCount; i++) {
                        const randomFactor = 0.5 + Math.random();
                        const finalSpeed = Math.max(0.1, targetSpeed * randomFactor);

                        // 生成随机名字
                        const surname = surnames[Math.floor(Math.random() * surnames.length)];
                        const givenName = givenNames[Math.floor(Math.random() * givenNames.length)];
                        const randomName = surname + givenName;

                        // 随机阵营
                        const randomFaction = factions[Math.floor(Math.random() * factions.length)];

                        // 分配固定随机颜色（基于角色ID确保一致性）
                        const colorIndex = (Date.now() + i) % colorPool.length;
                        const randomColor = colorPool[colorIndex];

                        newCharacters.push({
                            id: Date.now() + i,
                            name: randomName,
                            faction: randomFaction,
                            speed: parseFloat(finalSpeed.toFixed(2)),
                            isActive: true,
                            customColor: randomColor  // 添加自定义颜色属性
                        });

                        const intervalDays = Math.ceil(baseFactor / finalSpeed);
                        if (intervalDays > 0) {
                            totalActionsPerDay += 1 / intervalDays;
                        }
                    }
                    gameState.ctbManager.characters = newCharacters;

                    // 5. 安排首次行动
                    gameState.ctbManager.characters.forEach(char => {
                        const intervalDays = Math.ceil(baseFactor / char.speed);
                        const intervalHours = intervalDays * 24;

                        // 首次行动时间在 (0, intervalHours] 区间内随机分布
                        const initialDelayHours = Math.floor(Math.random() * intervalHours) + 1;
                        const triggerTime = gameState.timeManager.totalHours + initialDelayHours;

                        gameState.ctbManager.actionQueue.push({
                            id: gameState.ctbManager.nextActionId++,
                            characterId: char.id,
                            characterName: char.name,
                            triggerTime: triggerTime,
                            actionType: 'attack'
                        });
                    });

                    // 6. 排序行动队列
                    gameState.ctbManager.actionQueue.sort((a, b) => a.triggerTime - b.triggerTime);

                    gameState.ctbManager.isInitialized = true;

                    // 7. 显示理论计算结果
                    const resultText = `--- 100人测试结果 ---\n角色数量: ${characterCount}\n目标行动间隔: ${averageIntervalDays} 天\n理论平均每日行动: ${totalActionsPerDay.toFixed(2)} 人\n\n💡 适合测试行动顺序预测竖条效果`;
                    resultDiv.textContent = resultText;

                    addActionLog(`✅ 100人测试初始化完成，已生成 ${characterCount} 个角色。`);

                    // 8. 更新所有显示
                    updateAllDisplays();

                } catch (e) {
                    console.error("100人测试初始化出错:", e);
                    resultDiv.textContent = "初始化失败，请查看控制台。";
                    addActionLog("❌ 100人测试初始化失败。");
                }
            }, 50);
        }

        function runStressTest() {
            addActionLog("🔥 开始压力测试初始化...");

            const resultDiv = document.getElementById('stressTestResult');
            resultDiv.textContent = "初始化中...";

            setTimeout(() => {
                try {
                    // 1. 重置系统状态
                    resetCTB(true);

                    // 2. 设置参数
                    const characterCount = 10000;
                    const averageIntervalDays = 90;
                    const baseFactor = gameState.ctbManager.baseFactor;
                    const targetSpeed = baseFactor / averageIntervalDays;

                    // 3. 生成随机名字和颜色
                    const surnames = ['张', '李', '王', '赵', '陈', '刘', '杨', '黄', '周', '吴', '徐', '孙', '胡', '朱', '高', '林', '何', '郭', '马', '罗', '梁', '宋', '郑', '谢', '韩', '唐', '冯', '于', '董', '萧', '程', '曹', '袁', '邓', '许', '傅', '沈', '曾', '彭', '吕', '苏', '卢', '蒋', '蔡', '贾', '丁', '魏', '薛', '叶', '阎', '余', '潘', '杜', '戴', '夏', '钟', '汪', '田', '任', '姜', '范', '方', '石', '姚', '谭', '廖', '邹', '熊', '金', '陆', '郝', '孔', '白', '崔', '康', '毛', '邱', '秦', '江', '史', '顾', '侯', '邵', '孟', '龙', '万', '段', '雷', '钱', '汤', '尹', '黎', '易', '常', '武', '乔', '贺', '赖', '龚', '文'];
                    const givenNames = ['伟', '芳', '娜', '秀英', '敏', '静', '丽', '强', '磊', '军', '洋', '勇', '艳', '杰', '娟', '涛', '明', '超', '秀兰', '霞', '平', '刚', '桂英', '建华', '建国', '建军', '建平', '建华', '建明', '建强', '建伟', '建勇', '建杰', '建波', '建涛', '建斌', '建辉', '建峰', '建林', '建东', '建南', '建西', '建北', '建中', '建和', '建安', '建康', '建文', '建武', '建德', '建仁', '建义', '建礼', '建智', '建信', '建忠', '建孝', '建节', '建廉', '建耻', '建勇', '建刚', '建强', '建伟', '建杰', '建波', '建涛', '建斌', '建辉', '建峰', '建林', '建东', '建南', '建西', '建北', '建中', '建和', '建安', '建康', '建文', '建武', '建德', '建仁', '建义', '建礼', '建智', '建信', '建忠', '建孝', '建节', '建廉', '建耻'];
                    const factions = ['蜀国', '魏国', '吴国', '齐国', '楚国', '燕国', '韩国', '赵国', '秦国', '晋国', '宋国', '卫国', '郑国', '鲁国', '越国', '中山国', '滕国', '薛国', '莒国', '邾国', '郯国', '小邾国', '鄫国', '鄅国', '鄫国', '鄅国', '鄅国', '鄅国', '鄅国', '鄅国'];

                    // 预生成随机颜色池
                    const colorPool = [
                        '#e74c3c', '#3498db', '#f39c12', '#9b59b6', '#27ae60', '#1abc9c', '#34495e', '#e67e22',
                        '#8e44ad', '#2980b9', '#d35400', '#c0392b', '#16a085', '#f1c40f', '#e74c3c', '#3498db',
                        '#f39c12', '#9b59b6', '#27ae60', '#1abc9c', '#34495e', '#e67e22', '#8e44ad', '#2980b9',
                        '#d35400', '#c0392b', '#16a085', '#f1c40f', '#95a5a6', '#7f8c8d', '#2c3e50', '#ecf0f1'
                    ];

                    const newCharacters = [];
                    let totalActionsPerDay = 0;

                    // 4. 生成角色并计算理论平均值
                    for (let i = 0; i < characterCount; i++) {
                        const randomFactor = 0.5 + Math.random();
                        const finalSpeed = Math.max(0.1, targetSpeed * randomFactor);

                        // 生成随机名字
                        const surname = surnames[Math.floor(Math.random() * surnames.length)];
                        const givenName = givenNames[Math.floor(Math.random() * givenNames.length)];
                        const randomName = surname + givenName;

                        // 随机阵营
                        const randomFaction = factions[Math.floor(Math.random() * factions.length)];

                        // 分配固定随机颜色（基于角色ID确保一致性）
                        const colorIndex = (Date.now() + i) % colorPool.length;
                        const randomColor = colorPool[colorIndex];

                        newCharacters.push({
                            id: Date.now() + i,
                            name: randomName,
                            faction: randomFaction,
                            speed: parseFloat(finalSpeed.toFixed(2)),
                            isActive: true,
                            customColor: randomColor  // 添加自定义颜色属性
                        });

                        const intervalDays = Math.ceil(baseFactor / finalSpeed);
                        if (intervalDays > 0) {
                            totalActionsPerDay += 1 / intervalDays;
                        }
                    }
                    gameState.ctbManager.characters = newCharacters;

                    // 5. 安排首次行动
                    gameState.ctbManager.characters.forEach(char => {
                        const intervalDays = Math.ceil(baseFactor / char.speed);
                        const intervalHours = intervalDays * 24;

                        // 首次行动时间在 (0, intervalHours] 区间内随机分布
                        const initialDelayHours = Math.floor(Math.random() * intervalHours) + 1;
                        const triggerTime = gameState.timeManager.totalHours + initialDelayHours;

                        gameState.ctbManager.actionQueue.push({
                            id: gameState.ctbManager.nextActionId++,
                            characterId: char.id,
                            characterName: char.name,
                            triggerTime: triggerTime,
                            actionType: 'attack'
                        });
                    });

                    // 6. 排序行动队列
                    gameState.ctbManager.actionQueue.sort((a, b) => a.triggerTime - b.triggerTime);

                    gameState.ctbManager.isInitialized = true;

                    // 7. 显示理论计算结果
                    const resultText = `--- 压力测试结果 ---\n角色数量: ${characterCount}\n目标行动间隔: ${averageIntervalDays} 天\n理论平均每日行动: ${totalActionsPerDay.toFixed(2)} 人`;
                    resultDiv.textContent = resultText;

                    addActionLog(`✅ 压力测试初始化完成，已生成 ${characterCount} 个角色。`);

                    // 8. 更新所有显示
                    updateAllDisplays();

                } catch (e) {
                    console.error("压力测试初始化出错:", e);
                    resultDiv.textContent = "初始化失败，请查看控制台。";
                    addActionLog("❌ 压力测试初始化失败。");
                }
            }, 50);
        }

        // 页面加载时初始化显示
        document.addEventListener('DOMContentLoaded', function() {
            updateAllDisplays();
            addActionLog("系统启动完成，请点击'初始化CTB'开始");
        });

        // 技能系统相关变量
        let currentPrediction = null;
        let apiServerUrl = 'http://localhost:8001';

        // 引力坐标系统
        let gravityTargets = new Map(); // 存储每个角色的引力目标坐标
        let animationQueue = []; // 动画队列，支持连续操作
        let isAnimating = false; // 是否正在执行动画

        // 设置引力目标坐标
        function setGravityTarget(characterId, targetIndex) {
            const avatarHeight = 48;
            let targetY;

            if (targetIndex === -1) {
                // -1表示移动到底部外（消失效果）
                targetY = 400; // 移动到足够远的位置
            } else {
                targetY = targetIndex * avatarHeight;
            }

            gravityTargets.set(characterId, targetY);
        }

        // 清除引力目标坐标
        function clearGravityTarget(characterId) {
            gravityTargets.delete(characterId);
        }

        // 应用引力坐标动画
        function applyGravityAnimation() {
            if (isAnimating) {
                // 如果正在动画，加入队列
                animationQueue.push(() => applyGravityAnimation());
                return;
            }

            isAnimating = true;
            const bar = document.getElementById('actionOrderBar');
            const avatars = bar.querySelectorAll('.action-order-avatar');
            let animationsInProgress = 0;

            avatars.forEach((avatar, index) => {
                const characterId = avatar.dataset.characterId;
                const targetY = gravityTargets.get(characterId);

                if (targetY !== undefined) {
                    const currentY = parseInt(avatar.style.top) || (index * 48);

                    if (Math.abs(targetY - currentY) > 1) { // 有移动距离
                        animationsInProgress++;

                        // 根据位置设置不同的动画速度（前排快后排慢）
                        let speedClass = 'gravity-medium';
                        if (index < 3) {
                            speedClass = 'gravity-fast';
                        } else if (index > 5) {
                            speedClass = 'gravity-slow';
                        }

                        avatar.classList.add(speedClass);
                        avatar.style.top = `${targetY}px`;

                        // 动画完成后清理
                        setTimeout(() => {
                            avatar.classList.remove(speedClass);
                            animationsInProgress--;

                            if (animationsInProgress === 0) {
                                isAnimating = false;
                                // 处理队列中的下一个动画
                                if (animationQueue.length > 0) {
                                    const nextAnimation = animationQueue.shift();
                                    nextAnimation();
                                }
                            }
                        }, index < 3 ? 400 : index > 5 ? 800 : 600);
                    } else {
                        // 没有移动距离，直接清除目标
                        clearGravityTarget(characterId);
                    }
                }
            });

            // 如果没有动画需要执行
            if (animationsInProgress === 0) {
                isAnimating = false;
                if (animationQueue.length > 0) {
                    const nextAnimation = animationQueue.shift();
                    nextAnimation();
                }
            }
        }

        // 更新角色选择器
        function updateSkillTargetSelect() {
            const select = document.getElementById('skillTargetSelect');
            const ctb = gameState.ctbManager;

            // 清空现有选项
            select.innerHTML = '<option value="">选择角色...</option>';

            if (!ctb.isInitialized || ctb.actionQueue.length === 0) {
                return;
            }

            // 按行动顺序排序角色
            const sortedCharacters = [];
            ctb.actionQueue.forEach(action => {
                const character = ctb.characters.find(c => c.id === action.characterId);
                if (character && !sortedCharacters.find(c => c.id === character.id)) {
                    const timeUntil = action.triggerTime - gameState.timeManager.totalHours;
                    const days = Math.floor(timeUntil / 24);
                    const hours = Math.floor(timeUntil % 24);
                    const timeText = days > 0 ? `${days}天${hours}时后` : `${hours}时后`;

                    sortedCharacters.push({
                        ...character,
                        timeText: timeText,
                        triggerTime: action.triggerTime
                    });
                }
            });

            // 添加角色选项（按行动顺序）
            sortedCharacters.forEach(char => {
                const option = document.createElement('option');
                option.value = char.id;
                option.textContent = `${char.name} (${char.faction}) - ${char.timeText}`;
                select.appendChild(option);
            });
        }

        // 预测技能效果
        function predictSkillEffect() {
            const characterId = document.getElementById('skillTargetSelect').value;
            const delayHours = parseInt(document.getElementById('delayHoursInput').value);

            if (!characterId) {
                alert('请选择目标角色');
                return;
            }

            if (delayHours <= 0) {
                alert('延后小时数必须大于0');
                return;
            }

            const character = gameState.ctbManager.characters.find(c => c.id == characterId);
            if (!character) {
                alert('角色不存在');
                return;
            }

            // 模拟预测效果（实际应该调用API）
            try {
                // 创建预测数据
                const predictedActions = simulateSkillPrediction(characterId, delayHours);
                currentPrediction = {
                    characterId: characterId,
                    characterName: character.name,
                    delayHours: delayHours,
                    predictedActions: predictedActions
                };

                // 更新显示（不重新创建DOM）
                updateActionOrderBar(predictedActions);
                addActionLog(`🔮 预测技能效果：${character.name} 延后 ${delayHours} 小时`);

            } catch (error) {
                console.error('预测失败:', error);
                alert('预测失败，请查看控制台');
            }
        }

        // 模拟技能预测（实际项目中应该调用API）
        function simulateSkillPrediction(characterId, delayHours) {
            const ctb = gameState.ctbManager;
            const currentQueue = [...ctb.actionQueue];

            // 找到目标角色的行动
            const targetAction = currentQueue.find(action => action.characterId == characterId);
            if (!targetAction) {
                return currentQueue;
            }

            // 创建新的预测队列
            const predictedQueue = currentQueue.map(action => {
                if (action.characterId == characterId) {
                    return {
                        ...action,
                        triggerTime: action.triggerTime + delayHours,
                        isDelayed: true
                    };
                }
                return action;
            });

            // 重新排序
            predictedQueue.sort((a, b) => a.triggerTime - b.triggerTime);

            return predictedQueue;
        }

        // 应用技能效果
        function applySkillEffect() {
            if (!currentPrediction) {
                alert('请先预测技能效果');
                return;
            }

            const { characterId, characterName, delayHours } = currentPrediction;

            // 模拟应用技能效果（实际应该调用API）
            try {
                // 更新真实队列
                const ctb = gameState.ctbManager;
                const targetAction = ctb.actionQueue.find(action => action.characterId == characterId);

                if (targetAction) {
                    targetAction.triggerTime += delayHours;
                    // 重新排序
                    ctb.actionQueue.sort((a, b) => a.triggerTime - b.triggerTime);

                    addActionLog(`✨ 技能已应用：${characterName} 延后 ${delayHours} 小时`);

                    // 添加技能应用成功动画
                    const avatars = document.querySelectorAll('.action-order-avatar');
                    avatars.forEach(avatar => {
                        if (avatar.textContent.includes(characterName[0])) {
                            avatar.classList.add('skill-applied');
                            // 1秒后移除动画类
                            setTimeout(() => {
                                avatar.classList.remove('skill-applied');
                            }, 1000);
                        }
                    });

                    // 清除预测状态
                    clearPrediction();

                    // 更新显示
                    updateAllDisplays();
                }

            } catch (error) {
                console.error('应用技能失败:', error);
                alert('应用技能失败，请查看控制台');
            }
        }

        // 清除预测
        function clearPrediction() {
            currentPrediction = null;

            // 清除所有引力目标
            gravityTargets.clear();

            // 清除所有动画相关的CSS类并重置位置
            const avatars = document.querySelectorAll('.action-order-avatar');
            avatars.forEach(avatar => {
                avatar.classList.remove('delayed', 'prediction-mode', 'predicted', 'moving', 'teleporting', 'float-up', 'fade-out', 'gravity-moving', 'gravity-fast', 'gravity-medium', 'gravity-slow');
                // 重置样式
                avatar.style.borderColor = '';
                avatar.style.boxShadow = '';
                avatar.style.background = '';
                avatar.style.color = '';
                avatar.style.opacity = '';
                avatar.style.transition = '';
                avatar.style.top = '';
            });

            updateActionOrderBar(); // 使用真实数据更新
            addActionLog('🔄 已清除预测效果');
        }

        // 测试引力坐标动画
        function testGravityAnimation() {
            if (!gameState.ctbManager.isInitialized) {
                addActionLog("请先初始化CTB系统");
                return;
            }

            const bar = document.getElementById('actionOrderBar');
            const avatars = bar.querySelectorAll('.action-order-avatar');

            if (avatars.length === 0) {
                addActionLog("没有角色可以测试");
                return;
            }

            // 强制停止所有正在进行的动画
            isAnimating = false;
            animationQueue.length = 0;
            gravityTargets.clear();

            // 立即重置所有角色位置到原始状态
            avatars.forEach((avatar, index) => {
                avatar.style.transition = 'none';
                avatar.style.top = `${index * 48}px`;
                avatar.classList.remove('gravity-fast', 'gravity-medium', 'gravity-slow');
                setTimeout(() => {
                    avatar.style.transition = '';
                }, 50);
            });

            // 生成随机顺序
            const avatarCount = Math.min(avatars.length, 8);
            const randomOrder = [];
            for (let i = 0; i < avatarCount; i++) {
                randomOrder.push(i);
            }

            // Fisher-Yates 洗牌算法
            for (let i = randomOrder.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [randomOrder[i], randomOrder[j]] = [randomOrder[j], randomOrder[i]];
            }

            addActionLog(`🎯 测试引力动画：随机生成顺序 [${randomOrder.join(', ')}]`);

            // 延迟设置引力目标，确保重置完成
            setTimeout(() => {
                // 为每个角色设置引力目标
                avatars.forEach((avatar, index) => {
                    if (index < avatarCount) {
                        const characterId = avatar.dataset.characterId;
                        const targetIndex = randomOrder[index];

                        // 设置引力目标
                        setGravityTarget(characterId, targetIndex);
                    }
                });

                // 应用引力动画
                applyGravityAnimation();
            }, 100);

            // 3秒后恢复原始顺序
            setTimeout(() => {
                // 强制停止所有动画
                isAnimating = false;
                animationQueue.length = 0;
                gravityTargets.clear();

                // 立即重置到原始位置
                avatars.forEach((avatar, index) => {
                    if (index < avatarCount) {
                        avatar.style.transition = 'none';
                        avatar.style.top = `${index * 48}px`;
                        avatar.classList.remove('gravity-fast', 'gravity-medium', 'gravity-slow');
                        setTimeout(() => {
                            avatar.style.transition = '';
                        }, 50);
                    }
                });

                addActionLog("🎯 引力动画测试完成，恢复原始顺序");
            }, 3000);
        }

        // 预测演示功能
    </script>
</body>
</html>